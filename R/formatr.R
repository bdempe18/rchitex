sig_at <- function(v, sigs) {
  sa <- unlist(lapply(v, function(x) {
    tryCatch({
      names(sigs[x <= sigs])[[1]]
    }, error = function(e) ''
    )}))
  sa[is.na(sa)] <- ''
  sa
}

format_indep_names <- function(mods, indep_names=NA) {
  if (class(indep_names) == 'list')  return (indep_names)

  idn <- unique(unlist(lapply(mods, function(m) names(stats::coef(m)))))
  if ('(Intercept)' %in% idn) idn <- c(setdiff(idn, '(Intercept)'), '(Intercept)')

  idn <- as.list(idn)
  names(idn) <- idn
  idn
}

f_to_string <- function(f_stat, mod_class='lm') {
  out <- NA
    if (mod_class == "plm") {
    out <- as.character(format(f_stat$statistic,
                               format='d', big.mark=','))
    } else {
      out <- format(f_stat[1], format='d', big.mark=',')[1]
  }

  out
}

center_text <- function(text, width) {
  n_blank <- (width - nchar(text))%/%2
  paste0(strrep(' ', n_blank), text, strrep(' ', width-n_blank-nchar(text)))
}

roundr_fac <- function(max_precision, min_digs=0) {
  roundr <- function(num, nsmall=min_digs) {
    if (!is.numeric(num)) return(num)
    format(round(as.numeric(unlist(num), use.names=F),
                 max_precision), big.mark=',', nsmall=nsmall)
  }
  roundr
}

get_ar2 <- function(mod, mod_class) {
  out <- ''
  if (mod_class == "plm") out <- mod$r.squared[2]
  else out <- mod$adj.r.squared
  out
}

get_fits <- function(mods, stats='all', roundr, pre_stats=NA) {
  # <-- function returns a list of fit values
  # in the form of a list -->

  fit_lst <- list('lm'  = 'oraf',
                  'glm' = 'olc',
                  'plm' = 'oraf')

  # mods may need to be coerced to list
  # TODO: DEAL WITH ROBUST STANDARD ERRORS
  if (class(mods) != "list") mods <- list(mods)


  possibles <- c("Observations" = function(m) roundr(stats::nobs(m), 0),
                 "R2" = function(m) summary(m)$r.squared[1],
                 "Adjusted R2"  = function(m) {
                   get_ar2(summary(m), class(m)[1]) },
                 "F Statistic"  = function(m)  {
                   f_to_string(roundr(summary(m)$fstatistic), class(m)[1]) },
                 "AIC"          = function(m) summary(m)$aic,
                 "Log Likelihood" = function(m) stats::logLik(m)[1])
  # if stats are specificed, just spc vals are searched
  if (stats == 'all') {
    stats <- lapply(mods, class)
    stats <- unlist(lapply(stats, function(s) s[1]))
    stats <- paste0(fit_lst[stats], collapse='')
  }

  aliases <- list('c' = 'AIC',
                  'f' = 'F Statistic',
                  'a' = 'Adjusted R2',
                  'r' = 'R2',
                  'o' = 'Observations',
                  'l' = 'Log Likelihood')
  includes <- unique(unlist(strsplit(tolower(stats), '')))
  includes <- aliases[unlist(includes)]
  fit_char <- lapply(names(includes), function(p) {
    unlist(lapply(mods, function(m) {
      tryCatch({
        if  (grepl(p, fit_lst[class(m)[1]])) {
          roundr(possibles[[includes[[p]]]](m))
        } else ''
      }, error = function(e) NA)
    }), use.names=FALSE)
  })

  names(fit_char) <- names(possibles[unlist(includes)])

  if (!is.na(pre_stats))
    fit_char <- c(pre_stats, fit_char)

  fit_char <- lapply(fit_char, function(fc) {
    if (all(is.na(fc))) NULL
    else fc
  })

  Filter(Negate(is.null), fit_char)
}


gen_header <- function(code, type) {
  if (is.null(type)) return ('')

  header <- switch(type,
                   "latex" = "% Table generated by rchitex (Ben Dempe, 2019)",
                   "html"  = "<!-- Table generated by rchitex (Ben Dempe, 2019) -->\n",
                   "")

  paste0(header, code, collapse='', sep='\n')
}


